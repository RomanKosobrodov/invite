AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: >
  Lambda@Edge function for verifying JWT tokens issued by Cognito

Parameters:
  # UserPoolName:
  #   Type: String
  #   Description: Name of Cognito User Pool.
  # ReplyToEmail:
  #   Type: String
  #   Default: admin@kosobrodov.net
  #   Description: Return email address for the invitation email
  FunctionName:
    Type: String
    Default: edge-lambda-verify-token
    Description: Name of the function

Resources:
  # UserPool:
  #   Type: AWS::Cognito::UserPool
  #   Properties:
  #     AccountRecoverySetting:
  #       RecoveryMechanisms:
  #         - Name: admin_only
  #           Priority: 1
  #     AdminCreateUserConfig:
  #       AllowAdminCreateUserOnly: true
  #       UnusedAccountValidityDays: 60
  #     AliasAttributes:
  #       - email
  #     AutoVerifiedAttributes:
  #       - email
  #     DeviceConfiguration:
  #       ChallengeRequiredOnNewDevice: false
  #       DeviceOnlyRememberedOnUserPrompt: false
  #     EmailConfiguration:
  #       EmailSendingAccount: COGNITO_DEFAULT
  #       ReplyToEmailAddress: !Ref ReplyToEmail
  #     UserPoolName: !Ref UserPoolName
  #     UsernameConfiguration:
  #       CaseSensitive: false

  # UserPoolClient:
  #   Type: AWS::Cognito::UserPoolClient
  #   Properties:
  #     AccessTokenValidity: 12
  #     ClientName: !Sub "client-for-${UserPoolName}"
  #     EnableTokenRevocation: false
  #     ExplicitAuthFlows:
  #       - ALLOW_USER_SRP_AUTH
  #       - ALLOW_REFRESH_TOKEN_AUTH
  #     GenerateSecret: false
  #     IdTokenValidity: 12
  #     RefreshTokenValidity: 24
  #     TokenValidityUnits:
  #       AccessToken: "hours"
  #       IdToken: "hours"
  #       RefreshToken: "hours"
  #     UserPoolId: !Ref UserPool

  FrontendBucket:
    Type: "AWS::S3::Bucket"
    Properties:
      AccessControl: PublicRead
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: error.html
  BucketPolicy:
    Type: "AWS::S3::BucketPolicy"
    Properties:
      PolicyDocument:
        Id: frontend-authorisation
        Version: 2012-10-17
        Statement:
          - Sid: PublicReadForGetBucketObjects
            Effect: Allow
            Principal: "*"
            Action: "s3:GetObject"
            Resource: !Sub "arn:aws:s3:::${FrontendBucket}/*"
      Bucket: !Ref FrontendBucket

  AuthorisationFunctionLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !Sub "${AWS::StackName}-dependencies"
      Description: !Sub "Dependencies for ${AWS::StackName}"
      ContentUri: dependencies/
      CompatibleRuntimes:
        - python3.9

  AuthorisationFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Ref FunctionName
      Handler: index.handler
      Runtime: python3.9
      Layers:
        - !Ref AuthorisationFunctionLayer
      InlineCode: |
        import urllib.request
        import json
        import time
        from jose import jwk, jwt
        from jose.utils import base64url_decode

        # url = "${UserPool.ProviderURL}"
        # client_id = "${UserPoolClient}"

        iss = "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_CbewuFyl6"
        client_id = "55vr84njq7on1b48u28g68fi6m"

        url = iss + "/.well-known/jwks.json"

        with urllib.request.urlopen(url) as resp:
          key_set = json.loads(resp.read().decode("utf-8"))

        keys = dict()
        for k in key_set["keys"]:
          keys[k["kid"]] = jwk.construct(k)

        def handler(event, context):
          if "queryStringParameters" not in event:
            return {
              "error": "no query strings parameters"
            }
          token = event["queryStringParameters"].get("token", None)
          if token is None:
            return {
              "error": "token is not provided"
            }          
            
          try:
            header = jwt.get_unverified_header(token)
            kid = header.get("kid", "")
          except jwt.JWTError as e:
            return {"error": str(e)}

          parts = str(token).rsplit('.', 1)
          if len(parts) != 2:
            return {"error": "wrong token format"}
          message, encoded_signature = parts
          
          public_key = keys.get(kid, None)
          if public_key is None:
            return {"error": "Public key does not match"}
          
          decoded_signature = base64url_decode(encoded_signature.encode("utf-8"))
          verified = public_key.verify(message.encode("utf8"), decoded_signature)
          if not verified:
            return {"error": "Signature verification failed"}
            
          try:
            claims = jwt.get_unverified_claims(token)
          except jwt.JWTError as e:
            return {"error": str(e)}
            
          if claims.get("token_use", None) != "access":
            return {"error": "Wrong token type"};
          
          if claims.get("iss", None) != iss:
            return {"error": "Wrong ISS"}
          
          if claims.get("client_id", None) != client_id:
            return {"error": "Wrong client"}

          expiration = claims.get("exp", 0)
          if time.time() > expiration:
            return {"error": "Token expired"}
            
          return { 
            "status": "success"
          }

      FunctionUrlConfig:
        AuthType: NONE
        Cors:
          AllowOrigins:
            - "*"
Outputs:
  FrontendURL:
    Value: !GetAtt FrontendBucket.WebsiteURL
    Description: URL for authorisation frontend

  # UserPoolID:
  #   Value: !Ref UserPool
  #   Description: Cognito User Pool ID.

  # UserPoolClientID:
  #   Value: !Ref UserPoolClient
  #   Description: Cognito User Pool Client ID

  # UserPoolProviderURL:
  #   Value: !GetAtt UserPool.ProviderURL
  #   Description: The URL of the provider of the Amazon Cognito user pool.

  LambdaURL:
    Value: !GetAtt AuthorisationFunctionUrl.FunctionUrl
    Description: Lambda Function URL
